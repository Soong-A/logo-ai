//缺少放大放小，旋转，页面美化

"use client";

import { Suspense, useState, useEffect, Component, ErrorInfo, ReactNode, useRef, useCallback } from "react";
import { Canvas, useThree, extend, useFrame } from "@react-three/fiber";
import { OrbitControls, useGLTF } from "@react-three/drei";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { 
  ArrowLeft, Download, Box, HelpCircle, AlertCircle, 
  CheckCircle, RefreshCw, Image as ImageIcon, ChevronDown,
  Upload, Mouse
} from "lucide-react";
import Link from "next/link";
import Navbar from "@/components/landing/navbar";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { checkHistory } from "../actions/actions";
import { SelectLogo } from "@/db/schema";
import { useToast } from "@/hooks/use-toast";
import * as THREE from "three";

// 修复 DecalGeometry 导入
import { DecalGeometry } from 'three-stdlib';

// 扩展 Three.js 以支持 DecalGeometry
extend({ DecalGeometry });

// 修复：改进的贴花材质组件
const DecalMaterial = ({ texture, color = 0xffffff, opacity = 1 }) => {
  const materialRef = useRef<THREE.MeshPhongMaterial>(null);

  useEffect(() => {
    if (materialRef.current && texture) {
      materialRef.current.map = texture;
      materialRef.current.needsUpdate = true;
    }
  }, [texture]);

  return (
    <meshPhongMaterial
      ref={materialRef}
      color={color}
      map={texture}
      transparent
      opacity={opacity}
      polygonOffset
      polygonOffsetFactor={-50} // 增加深度偏移因子
      polygonOffsetUnits={-50}  // 增加深度偏移单位
      shininess={5} // 进一步降低光泽度
    />
  );
};

// 改进的贴花组件 - 增加厚度和表面距离
const Decal = ({ 
  position, 
  normal, 
  textureUrl, 
  size = [0.3, 0.3, 0.15], // 增加默认厚度从 0.05 到 0.15
  isSelected = false,
  modelMesh,
  onClick
}: { 
  position: [number, number, number];
  normal: [number, number, number];
  textureUrl: string;
  size?: [number, number, number];
  isSelected?: boolean;
  modelMesh?: THREE.Mesh | null;
  onClick: () => void;
}) => {
  const [texture, setTexture] = useState<THREE.Texture | null>(null);
  const [loadError, setLoadError] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const meshRef = useRef<THREE.Mesh>(null);
  const decalRef = useRef<THREE.Group>(null);
  
  // 使用更精确的向量计算，增加与表面的距离
  const decalPosition = new THREE.Vector3(...position);
  const decalNormal = new THREE.Vector3(...normal).normalize();
  
  // 增加贴图与模型表面的基础距离
  const surfaceOffset = 0.0001; // 从 0.01 增加到 0.03
  const adjustedPosition = decalPosition.clone().add(
    decalNormal.clone().multiplyScalar(surfaceOffset)
  );
  
  const decalSize = new THREE.Vector3(...size);

  // 加载纹理
  useEffect(() => {
    let mounted = true;
    setIsLoading(true);
    setLoadError(false);

    const loadTexture = async () => {
      try {
        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load(
          textureUrl,
          (loadedTexture) => {
            if (!mounted) return;
            
            loadedTexture.wrapS = THREE.ClampToEdgeWrapping;
            loadedTexture.wrapT = THREE.ClampToEdgeWrapping;
            loadedTexture.minFilter = THREE.LinearMipmapLinearFilter;
            loadedTexture.magFilter = THREE.LinearFilter;
            loadedTexture.colorSpace = THREE.SRGBColorSpace;
            loadedTexture.anisotropy = 4;
            
            setTexture(loadedTexture);
            setLoadError(false);
            setIsLoading(false);
          },
          undefined,
          (error) => {
            if (!mounted) return;
            console.error("纹理加载失败:", error);
            setLoadError(true);
            setIsLoading(false);
          }
        );
      } catch (error) {
        if (!mounted) return;
        console.error("加载过程出错:", error);
        setLoadError(true);
        setIsLoading(false);
      }
    };

    loadTexture();

    return () => {
      mounted = false;
      if (texture) {
        texture.dispose();
      }
    };
  }, [textureUrl]);

  // 改进的曲面贴合计算
  const calculateDecalOrientation = useCallback((
    position: THREE.Vector3, 
    normal: THREE.Vector3,
    mesh?: THREE.Mesh | null
  ) => {
    try {
      const up = new THREE.Vector3(0, 1, 0);
      const quaternion = new THREE.Quaternion();
      
      if (Math.abs(normal.y) > 0.95) {
        quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);
      } else {
        quaternion.setFromUnitVectors(up, normal);
      }
      
      const orientation = new THREE.Euler();
      orientation.setFromQuaternion(quaternion);
      
      return orientation;
    } catch (error) {
      console.error("计算朝向失败:", error);
      return new THREE.Euler();
    }
  }, []);

  // 创建和改进 DecalGeometry，增加厚度
  useEffect(() => {
    if (!meshRef.current || !modelMesh || !texture) return;

    try {
      const orientation = calculateDecalOrientation(adjustedPosition, decalNormal, modelMesh);
      
      // 显著增加贴图厚度
      const adjustedSize = new THREE.Vector3(
        size[0],
        size[1], 
        Math.max(0.5, size[2]) // 显著增加最小深度从 0.01 到 0.08
      );

      const decalGeometry = new DecalGeometry(
        modelMesh,
        adjustedPosition, // 使用调整后的位置
        orientation,
        adjustedSize
      );

      if (meshRef.current.geometry) {
        meshRef.current.geometry.dispose();
      }
      meshRef.current.geometry = decalGeometry;

      if (meshRef.current.material) {
        const material = meshRef.current.material as THREE.MeshPhongMaterial;
        material.map = texture;
        material.needsUpdate = true;
        material.polygonOffset = true;
        material.polygonOffsetFactor = -4; // 增加深度偏移
        material.polygonOffsetUnits = -2;  // 增加深度偏移
        material.shininess = 5;
        material.transparent = true;
        material.opacity = isSelected ? 1 : 0.95;
      }

    } catch (error) {
      console.error("创建 DecalGeometry 失败，使用备用方案:", error);
      try {
        if (meshRef.current.geometry) {
          meshRef.current.geometry.dispose();
        }
        
        // 创建更厚的几何体
        const geometry = new THREE.BoxGeometry(size[0], size[1], size[2]); // 使用立方体而不是平面
        
        // 根据法线方向添加弯曲效果
        const positions = geometry.attributes.position.array as Float32Array;
        for (let i = 0; i < positions.length; i += 3) {
          // 对顶面顶点进行弯曲（z > 0 的面）
          if (positions[i + 2] > 0) {
            const x = positions[i] / (size[0] / 2);
            const y = positions[i + 1] / (size[1] / 2);
            const distance = Math.sqrt(x * x + y * y);
            const curve = Math.sin(distance * 1.5) * 0.03; // 增加弯曲效果
            positions[i + 2] += curve;
          }
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
        
        meshRef.current.geometry = geometry;
        meshRef.current.position.copy(adjustedPosition);
        
        // 设置朝向
        const box = meshRef.current;
        box.lookAt(
          box.position.x + decalNormal.x,
          box.position.y + decalNormal.y, 
          box.position.z + decalNormal.z
        );
        
      } catch (fallbackError) {
        console.error("备用方案也失败:", fallbackError);
      }
    }
  }, [position, normal, modelMesh, texture, size, calculateDecalOrientation, isSelected, adjustedPosition, decalNormal]);

  // 每帧微调贴图位置
  useFrame(() => {
    if (!meshRef.current || !modelMesh) return;
    
    try {
      const worldPosition = new THREE.Vector3();
      meshRef.current.getWorldPosition(worldPosition);
      
      if (modelMesh.geometry.boundingBox) {
        const distance = worldPosition.distanceTo(modelMesh.position);
        if (distance > 5) {
          meshRef.current.position.copy(adjustedPosition);
        }
      }
    } catch (error) {
      // 忽略帧更新中的错误
    }
  });

  // 清理几何体
  useEffect(() => {
    return () => {
      if (meshRef.current?.geometry) {
        meshRef.current.geometry.dispose();
      }
    };
  }, []);

  if (isLoading) {
    return (
      <group ref={decalRef}>
        <mesh ref={meshRef} position={adjustedPosition} onClick={onClick}>
          <sphereGeometry args={[0.08, 6, 6]} />
          <meshBasicMaterial color="#4ecdc4" transparent opacity={0.8} />
        </mesh>
      </group>
    );
  }

  if (loadError || !texture) {
    return (
      <group ref={decalRef}>
        <mesh ref={meshRef} position={adjustedPosition} onClick={onClick}>
          <sphereGeometry args={[0.08, 6, 6]} />
          <meshBasicMaterial color="#ff6b6b" transparent opacity={0.9} />
        </mesh>
      </group>
    );
  }

  return (
    <group ref={decalRef}>
      <mesh 
        ref={meshRef} 
        onClick={onClick}
      >
        <DecalMaterial 
          texture={texture} 
          opacity={isSelected ? 1 : 0.95}
          color={isSelected ? 0xf0f0f0 : 0xffffff}
        />
      </mesh>
      
      {/* 改进的选中状态指示器 */}
      {isSelected && (
        <mesh position={adjustedPosition}>
          <ringGeometry args={[Math.max(size[0], size[1]) * 0.6, Math.max(size[0], size[1]) * 0.7, 16]} />
          <meshBasicMaterial 
            color="#3b82f6" 
            transparent 
            opacity={0.8}
            side={THREE.DoubleSide}
          />
        </mesh>
      )}
    </group>
  );
};

// 历史图片接口定义
interface HistoryImage {
  id: string;
  url: string;
  name: string;
}

// 定义模型配置的类型接口
interface ModelConfig {
  id: string;
  name: string;
  path: string;
  description: string;
  scale: number;
  position: [number, number, number];
}

// 错误边界组件
class ErrorBoundary extends Component<{ children: ReactNode; fallback: ReactNode }, { hasError: boolean }> {
  constructor(props: { children: ReactNode; fallback: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): { hasError: boolean } {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error("3D模型加载错误详情:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

// 模型配置
const MODEL_CONFIG: ModelConfig[] = [
  { 
    id: "test-cube", 
    name: "测试几何体", 
    path: "",
    description: "内置测试几何体 - 用于验证3D功能是否正常",
    scale: 1,
    position: [0, 0, 0]
  },
  { 
    id: "duck", 
    name: "贝雷帽", 
    path: "/Hat2-3D/scene.gltf",
    description: "可靠的在线测试模型，用于验证网络加载功能",
    scale: 0.1,
    position: [0, 0, 0]
  },
  { 
    id: "local-model", 
    name: "渔夫帽", 
    path: "/Hat1-3D/scene.gltf",
    description: "本地GLTF模型文件，需放置在public/3D目录下",
    scale: 0.1,
    position: [0, 0, 0]
  }
];

// 鼠标控制说明组件
const MouseControlsInfo = () => {
  return (
    <div className="bg-card border rounded-lg p-4 shadow-lg">
      <h3 className="text-sm font-medium mb-3 flex items-center gap-2">
        <Mouse className="h-4 w-4 text-primary" />
        鼠标控制
      </h3>
      
      <div className="space-y-3 text-sm">
        <div className="flex items-start gap-2">
          <div className="w-6 h-6 bg-primary/20 rounded-full flex items-center justify-center flex-shrink-0">
            <Mouse className="h-3 w-3 text-primary" />
          </div>
          <div>
            <p className="font-medium">旋转视图</p>
            <p className="text-muted-foreground text-xs">按住左键拖动鼠标</p>
          </div>
        </div>
        
        <div className="flex items-start gap-2">
          <div className="w-6 h-6 bg-primary/20 rounded-full flex items-center justify-center flex-shrink-0">
            <svg className="h-3 w-3 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
            </svg>
          </div>
          <div>
            <p className="font-medium">缩放</p>
            <p className="text-muted-foreground text-xs">滚动鼠标滚轮</p>
          </div>
        </div>
        
        <div className="flex items-start gap-2">
          <div className="w-6 h-6 bg-primary/20 rounded-full flex items-center justify-center flex-shrink-0">
            <Mouse className="h-3 w-3 text-primary" />
          </div>
          <div>
            <p className="font-medium">放置贴图</p>
            <p className="text-muted-foreground text-xs">双击模型表面放置选中贴图</p>
          </div>
        </div>
        
        <div className="flex items-start gap-2">
          <div className="w-6 h-6 bg-primary/20 rounded-full flex items-center justify-center flex-shrink-0">
            <Mouse className="h-3 w-3 text-primary" />
          </div>
          <div>
            <p className="font-medium">移动贴图</p>
            <p className="text-muted-foreground text-xs">选中贴图后双击新位置移动</p>
          </div>
        </div>
        
        <div className="mt-3 p-2 bg-blue-50 rounded border border-blue-200">
          <p className="text-xs text-blue-700 font-medium">提示：先选择图片或贴图，然后双击模型表面放置或移动</p>
        </div>
      </div>
    </div>
  );
};

// 改进模型加载器中的双击处理，增加表面距离
const ModelLoader = ({ 
  model, 
  appliedTextures,
  selectedTextureId,
  onTextureSelect,
  onDoubleClick
}: { 
  model: ModelConfig;
  appliedTextures: Array<{
    id: string;
    url: string;
    position: [number, number, number];
    normal: [number, number, number];
    modelMesh?: THREE.Mesh | null;
  }>;
  selectedTextureId: string | null;
  onTextureSelect: (textureId: string) => void;
  onDoubleClick: (position: [number, number, number], normal: [number, number, number], modelMesh: THREE.Mesh | null) => void;
}) => {
  const modelRef = useRef<THREE.Group | null>(null);
  const { scene, camera, raycaster, gl } = useThree();
  const [modelMeshes, setModelMeshes] = useState<THREE.Mesh[]>([]);
  
  // 收集模型中的所有网格
  useEffect(() => {
    if (modelRef.current) {
      const meshes: THREE.Mesh[] = [];
      modelRef.current.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          if (child.geometry) {
            child.geometry.computeVertexNormals();
            meshes.push(child);
          }
        }
      });
      setModelMeshes(meshes);
    }
  }, [model]);
  
  // 改进的双击处理，增加表面距离
  const handleDoubleClick = useCallback((event: MouseEvent) => {
    event.preventDefault();
    
    const rect = gl.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    raycaster.far = 1000;
    
    const intersects = raycaster.intersectObjects(modelMeshes, true);
    
    if (intersects.length > 0) {
      const intersect = intersects[0];
      const point = intersect.point;
      
      let normal = new THREE.Vector3(0, 1, 0);
      if (intersect.face) {
        if (intersect.face.normal.length() > 0) {
          normal = intersect.face.normal.clone();
        }
      }
      
      const mesh = intersect.object as THREE.Mesh;
      if (mesh.geometry.attributes.normal && intersect.face) {
        const normals = mesh.geometry.attributes.normal;
        const normalVector = new THREE.Vector3()
          .fromArray(normals.array, intersect.face.a * 3)
          .add(new THREE.Vector3().fromArray(normals.array, intersect.face.b * 3))
          .add(new THREE.Vector3().fromArray(normals.array, intersect.face.c * 3))
          .normalize();
        
        if (normalVector.length() > 0.1) {
          normal = normalVector;
        }
      }
      
      normal.normalize();
      
      // 显著增加与模型表面的距离，从 0.01 增加到 0.05
      const surfaceDistance = 0.05;
      const adjustedPoint = point.clone().add(normal.clone().multiplyScalar(surfaceDistance));
      
      onDoubleClick(
        [adjustedPoint.x, adjustedPoint.y, adjustedPoint.z] as [number, number, number],
        [normal.x, normal.y, normal.z] as [number, number, number],
        mesh
      );
    }
  }, [gl, scene, camera, raycaster, onDoubleClick, modelMeshes]);

  // 绑定双击事件
  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener('dblclick', handleDoubleClick);
    
    return () => {
      canvas.removeEventListener('dblclick', handleDoubleClick);
    };
  }, [gl, handleDoubleClick]);
  
  if (!model.path) {
    return (
      <group ref={modelRef}>
        <mesh position={model.position}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color="#3b82f6" />
        </mesh>
        <mesh position={[-1.5, 0, 0]}>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshStandardMaterial color="#ef4444" />
        </mesh>
        <mesh position={[1.5, 0, 0]}>
          <coneGeometry args={[0.5, 1, 32]} />
          <meshStandardMaterial color="#10b981" />
        </mesh>
        <axesHelper args={[2]} />
        
        {appliedTextures.map((texture) => (
          <Decal
            key={texture.id}
            textureUrl={texture.url}
            position={texture.position}
            normal={texture.normal}
            size={[0.4, 0.4, 0.15]} // 调整默认大小，增加厚度
            isSelected={selectedTextureId === texture.id}
            modelMesh={texture.modelMesh}
            onClick={() => onTextureSelect(texture.id)}
          />
        ))}
      </group>
    );
  }

  const { scene: modelScene } = useGLTF(model.path);
  
  // 改进模型设置
  modelScene.scale.set(model.scale, model.scale, model.scale);
  modelScene.position.set(...model.position);
  modelScene.castShadow = true;
  modelScene.receiveShadow = true;
  
  // 确保模型几何体有正确的法线
  modelScene.traverse((child) => {
    if (child instanceof THREE.Mesh && child.geometry) {
      child.geometry.computeVertexNormals();
    }
  });
  
  return (
    <group ref={modelRef}>
      <primitive object={modelScene} />
      {appliedTextures.map((texture) => (
        <Decal
          key={texture.id}
          textureUrl={texture.url}
          position={texture.position}
          normal={texture.normal}
          size={[0.25, 0.25, 0.15]} // 调整默认大小，增加厚度
          isSelected={selectedTextureId === texture.id}
          modelMesh={texture.modelMesh}
          onClick={() => onTextureSelect(texture.id)}
        />
      ))}
    </group>
  );
};

// 场景内容组件
const SceneContent = ({ 
  model, 
  appliedTextures,
  selectedTextureId,
  onTextureSelect,
  onDoubleClick
}: { 
  model: ModelConfig;
  appliedTextures: Array<{
    id: string;
    url: string;
    position: [number, number, number];
    normal: [number, number, number];
  }>;
  selectedTextureId: string | null;
  onTextureSelect: (textureId: string) => void;
  onDoubleClick: (
    position: [number, number, number], 
    normal: [number, number, number], 
    modelMesh: THREE.Mesh | null
  ) => void;
}) => {
  return (
    <>
      {/* 光照系统 */}
      <ambientLight intensity={0.7} />
      <directionalLight position={[5, 5, 5]} intensity={1} />
      <hemisphereLight args={["#87CEEB", "#8B7355", 0.3]} />
      
      {/* 添加 OrbitControls 支持鼠标交互 */}
      <OrbitControls
        enableDamping={true}
        dampingFactor={0.05}
        rotateSpeed={0.5}
        panSpeed={0.5}
        zoomSpeed={0.8}
        minDistance={1}
        maxDistance={20}
        enablePan={true}
        enableRotate={true}
        enableZoom={true}
      />
      
     {/* 浅色地面 - 与背景渐变协调 */}
    <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -1.5, 0]} receiveShadow>
        <planeGeometry args={[10, 10]} />
        <shadowMaterial transparent opacity={0.3} />
    </mesh>
      
      <Suspense fallback={
        <group>
          <mesh position={[0, 0, 0]}>
            <boxGeometry args={[1, 1, 1]} />
            <meshStandardMaterial color="#f59e0b" />
          </mesh>
          <axesHelper args={[2]} />
        </group>
      }>
        <ModelLoader 
          model={model} 
          appliedTextures={appliedTextures}
          selectedTextureId={selectedTextureId}
          onTextureSelect={onTextureSelect}
          onDoubleClick={onDoubleClick}
        />
      </Suspense>
    </>
  );
};

// 3D场景组件
const ModelScene = ({ 
  model, 
  appliedTextures,
  selectedTextureId,
  onTextureSelect,
  onDoubleClick
}: { 
  model: ModelConfig;
  appliedTextures: Array<{
    id: string;
    url: string;
    position: [number, number, number];
    normal: [number, number, number];
  }>;
  selectedTextureId: string | null;
  onTextureSelect: (textureId: string) => void;
  onDoubleClick: (
    position: [number, number, number], 
    normal: [number, number, number], 
    modelMesh: THREE.Mesh | null
  ) => void;
}) => {
  const canvasRef = useRef<HTMLDivElement>(null);
  
  // 错误提示组件
  const ErrorFallback = () => (
    <div className="h-full w-full flex flex-col items-center justify-center gap-4 p-6">
      <AlertCircle className="h-10 w-10 text-red-500" />
      <h3 className="text-lg font-medium text-red-500">模型加载失败</h3>
      <p className="text-sm text-muted-foreground text-center max-w-md">
        可能是文件不存在、格式错误或网络问题
      </p>
      <Button 
        variant="outline" 
        size="sm" 
        onClick={() => window.location.reload()}
        className="gap-1 mt-2"
      >
        <RefreshCw className="h-3 w-3" />
        重试
      </Button>
    </div>
  );

  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <div 
        ref={canvasRef}
        className="h-full w-full"
      >
        <Canvas 
                 camera={{ 
                   position: [3, 3, 3], 
                   fov: 50,
                   near: 0.1,
                   far: 1000
                 }}
                 style={{ 
                   background: `
                     linear-gradient(to bottom, #f8f7ff 0%, #f0edff 25%, #ffffff 60%),
                     radial-gradient(circle at 20% 20%, rgba(168, 139, 245, 0.08) 0%, transparent 50%)
                   `
                 }}
               >
                 <Suspense fallback={
                   <div className="w-full h-full flex items-center justify-center">
                     <RefreshCw className="h-8 w-8 animate-spin text-primary" />
                   </div>
                 }>
                   <SceneContent 
                     model={model} 
                     appliedTextures={appliedTextures}
                     selectedTextureId={selectedTextureId}
                     onTextureSelect={onTextureSelect}
                     onDoubleClick={onDoubleClick}
                   />
                 </Suspense>
               </Canvas>
      </div>
    </ErrorBoundary>
  );
};

// 状态指示器组件
const StatusIndicator = ({ currentModel }: { currentModel: ModelConfig | undefined }) => {
  const [fileExists, setFileExists] = useState<boolean | null>(null);
  
  // 检查文件是否存在
  const checkFileExists = async (path: string) => {
    try {
      const response = await fetch(path, { method: 'HEAD' });
      setFileExists(response.ok);
    } catch (error) {
      setFileExists(false);
    }
  };

  // 当模型改变时检查文件
  useEffect(() => {
    if (currentModel?.path) {
      checkFileExists(currentModel.path);
    }
  }, [currentModel]);

  if (!currentModel?.path) return null;

  return (
    <div className="mt-2 flex items-center gap-2 text-xs">
      {fileExists === true && (
        <div className="flex items-center gap-1 text-green-600">
          <CheckCircle className="h-3 w-3" />
          <span>文件存在</span>
        </div>
      )}
      {fileExists === false && (
        <div className="flex items-center gap-1 text-red-600">
          <AlertCircle className="h-3 w-3" />
          <span>文件不存在</span>
        </div>
      )}
      {fileExists === null && (
        <div className="flex items-center gap-1 text-amber-600">
          <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-amber-600"></div>
          <span>检查文件中...</span>
        </div>
      )}
    </div>
  );
};

// 历史图片卡片组件
const HistoryImageCard = ({ 
  image, 
  onSelect,
  imageData
}: { 
  image: SelectLogo; 
  onSelect: (url: string) => void;
  imageData?: string;
}) => {
  return (
    <div 
      className="flex-shrink-0 w-32 h-32 group relative rounded-lg overflow-hidden border-2 border-transparent hover:border-primary transition-all cursor-pointer"
      onClick={() => imageData && onSelect(imageData)}
    >
      {imageData ? (
        <img 
          src={imageData} 
          alt={`历史图片 ${image.id}`} 
          className="w-full h-full object-cover"
        />
      ) : (
        <div className="w-full h-full bg-muted flex items-center justify-center">
          <RefreshCw className="h-6 w-6 animate-spin text-muted-foreground" />
        </div>
      )}
      <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
        <Button size="sm" variant="secondary" className="h-6 text-xs">
          {imageData ? "选择" : "加载中..."}
        </Button>
      </div>
    </div>
  );
};

// 主页面组件
export default function ThreeDViewerPage() {
  const [selectedModelId, setSelectedModelId] = useState<string>("test-cube");
  const [isDownloading, setIsDownloading] = useState<boolean>(false);
  const [historyImages, setHistoryImages] = useState<SelectLogo[]>([]);
  const [isLoadingHistory, setIsLoadingHistory] = useState<boolean>(true);
  const [selectedImageUrl, setSelectedImageUrl] = useState<string | null>(null);
  const [isHistoryOpen, setIsHistoryOpen] = useState<boolean>(false);
  const [appliedTextures, setAppliedTextures] = useState<Array<{
    id: string;
    url: string;
    position: [number, number, number];
    normal: [number, number, number];
    modelMesh?: THREE.Mesh | null;
  }>>([]);
  const [selectedTextureId, setSelectedTextureId] = useState<string | null>(null);
  const [loadedImages, setLoadedImages] = useState<{[key: number]: string}>({});
  const [textureSize, setTextureSize] = useState<number>(0.25);
  const { toast } = useToast();

  const currentModel: ModelConfig | undefined = MODEL_CONFIG.find(m => m.id === selectedModelId);

  // 使用 useRef 来跟踪选中的贴图ID，避免闭包问题
  const selectedTextureIdRef = useRef(selectedTextureId);
  useEffect(() => {
    selectedTextureIdRef.current = selectedTextureId;
  }, [selectedTextureId]);

  // 使用 useRef 来跟踪选中的图片URL，避免闭包问题
  const selectedImageUrlRef = useRef(selectedImageUrl);
  useEffect(() => {
    selectedImageUrlRef.current = selectedImageUrl;
  }, [selectedImageUrl]);

  // 加载历史图片
  useEffect(() => {
    const loadHistory = async () => {
      try {
        setIsLoadingHistory(true);
        const history = await checkHistory();
        if (history) {
          setHistoryImages(history);
        } else {
          toast({
            title: "加载历史记录失败",
            description: "无法获取您的历史图片",
            variant: "destructive",
          });
        }
      } catch (error) {
        console.error("加载历史图片错误:", error);
        toast({
          title: "错误",
          description: "加载历史图片时发生错误",
          variant: "destructive",
        });
      } finally {
        setIsLoadingHistory(false);
      }
    };

    loadHistory();
  }, [toast]);

  // 懒加载图片数据
  const loadImageData = async (logoId: number) => {
    if (loadedImages[logoId]) return;
    
    try {
      const response = await fetch(`/api/logo-image?id=${logoId}`);
      const data = await response.json();
      
      if (data.success && data.imageData) {
        setLoadedImages(prev => ({
          ...prev,
          [logoId]: data.imageData
        }));
      }
    } catch (error) {
      console.error('加载图片数据失败:', error);
    }
  };

  // 当历史面板展开时加载可见图片
  useEffect(() => {
    if (isHistoryOpen && historyImages.length > 0) {
      // 只加载前6张图片（首屏可见）
      const imagesToLoad = historyImages.slice(0, 6);
      imagesToLoad.forEach(image => {
        loadImageData(image.id);
      });
    }
  }, [isHistoryOpen, historyImages]);

  const handleDownloadModel = () => {
    if (!currentModel?.path) return;
    
    setIsDownloading(true);
    try {
      const a = document.createElement("a");
      a.href = currentModel.path;
      a.download = currentModel.path.split("/").pop() || "model.gltf";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } catch (error) {
      console.error("下载失败:", error);
      toast({
        title: "下载失败",
        description: "无法下载模型文件",
        variant: "destructive",
      });
    } finally {
      setIsDownloading(false);
    }
  };

  // 处理历史图片选择
  const handleImageSelect = (url: string) => {
    setSelectedImageUrl(url);
    setSelectedTextureId(null); // 取消选中的贴图
    toast({
      title: "已选择图片",
      description: "双击模型表面放置图片",
    });
  };

  // 处理贴图选择
  const handleTextureSelect = (textureId: string) => {
    setSelectedTextureId(textureId);
    setSelectedImageUrl(null); // 取消选中的历史图片
    
    const texture = appliedTextures.find(t => t.id === textureId);
    if (texture) {
      toast({
        title: "已选中贴图",
        description: "双击模型表面移动贴图到新位置",
      });
    }
  };

  // 处理模型双击
  const handleModelDoubleClick = (
    position: [number, number, number], 
    normal: [number, number, number], 
    modelMesh: THREE.Mesh | null
  ) => {
    // 使用 ref 的当前值来避免闭包问题
    const currentSelectedTextureId = selectedTextureIdRef.current;
    const currentSelectedImageUrl = selectedImageUrlRef.current;

    if (currentSelectedTextureId) {
      // 如果有选中的贴图，将其移动到双击位置
      setAppliedTextures(prev => 
        prev.map(texture => 
          texture.id === currentSelectedTextureId 
            ? { ...texture, position, normal, modelMesh }
            : texture
        )
      );
      
      // 移动完成后取消选中贴图
      setSelectedTextureId(null);
      
      toast({
        title: "贴图已移动",
        description: "贴图已移动到新位置并重新计算曲面贴合",
      });
    } else if (currentSelectedImageUrl) {
      // 如果有选中的图片，将其放置在双击位置
      const newTexture = {
        id: `texture-${Date.now()}`,
        url: currentSelectedImageUrl,
        position,
        normal,
        modelMesh // 保存模型网格信息用于贴花
      };
      
      setAppliedTextures(prev => [...prev, newTexture]);
      setSelectedImageUrl(null);
      
      toast({
        title: "图片已应用到模型",
        description: "图片已成功贴合到3D模型表面",
      });
    } else {
      toast({
        title: "未选择图片或贴图",
        description: "请先选择一张图片或贴图",
        variant: "destructive",
      });
    }
  };

  // 清除所有纹理
  const handleClearTextures = () => {
    setAppliedTextures([]);
    setSelectedImageUrl(null);
    setSelectedTextureId(null);
    toast({
      title: "已清除所有贴图",
      description: "所有应用的图片贴图已被移除",
    });
  };

  // 移除单个纹理
  const handleRemoveTexture = (textureId: string) => {
    setAppliedTextures(prev => prev.filter(t => t.id !== textureId));
    if (selectedTextureId === textureId) {
      setSelectedTextureId(null);
    }
  };

  // 取消选中当前贴图
  const handleDeselectTexture = () => {
    setSelectedTextureId(null);
    toast({
      title: "已取消选中",
      description: "贴图选中状态已取消",
    });
  };

  // 取消选中的图片
  const handleDeselectImage = () => {
    setSelectedImageUrl(null);
    toast({
      title: "已取消选择",
      description: "图片选择已取消",
    });
  };

  // 切换历史面板展开状态
  const toggleHistoryPanel = () => {
    setIsHistoryOpen(!isHistoryOpen);
  };

  return (
    <div className="min-h-screen bg-background overflow-hidden">
      <Navbar />
      
      <div className="max-w-7xl mx-auto mt-16 px-4 sm:px-6 lg:px-8 py-8">
        {/* 导航栏 */}
        <div className="mb-6 flex flex-wrap gap-4 items-center justify-between">
          <Link href="/gallery">
            <Button variant="outline" className="gap-2">
              <ArrowLeft className="h-4 w-4" />
              返回画廊
            </Button>
          </Link>
          
          <div className="flex gap-2">
            {selectedTextureId && (
              <Button 
                onClick={handleDeselectTexture}
                variant="outline"
                className="gap-2 bg-blue-100 border-blue-300"
                size="sm"
              >
                <AlertCircle className="h-4 w-4 text-blue-600" />
                取消选中贴图
              </Button>
            )}
            
            {selectedImageUrl && (
              <Button 
                onClick={handleDeselectImage}
                variant="outline"
                className="gap-2 bg-amber-100 border-amber-300"
                size="sm"
              >
                <AlertCircle className="h-4 w-4 text-amber-600" />
                取消选择图片
              </Button>
            )}
            
            {appliedTextures.length > 0 && (
              <Button 
                onClick={handleClearTextures}
                variant="outline"
                className="gap-2"
                size="sm"
              >
                <RefreshCw className="h-4 w-4" />
                清除贴图 ({appliedTextures.length})
              </Button>
            )}
            
            {currentModel?.path && (
              <Button 
                onClick={handleDownloadModel} 
                disabled={isDownloading}
                className="gap-2"
                variant="outline"
              >
                <Download className="h-4 w-4" />
                {isDownloading ? "下载中..." : "下载模型"}
              </Button>
            )}
          </div>
        </div>
        
        <h1 className="text-3xl font-semibold mb-6">
          3D模型查看器 - 增强厚度智能曲面贴图
        </h1>
        
        <div className="grid grid-cols-1 lg:grid-cols-5 gap-6 mb-6">
          {/* 控制面板 */}
          <Card className="lg:col-span-2">
            <CardContent className="p-6">
              <h3 className="text-lg font-medium mb-4 flex items-center gap-2">
                <Box className="h-5 w-5 text-primary" />
                模型控制
              </h3>
              
              {/* 模型选择器 */}
              <div className="mb-6">
                <label className="text-sm font-medium mb-2 block">选择模型</label>
                <Select 
                  value={selectedModelId} 
                  onValueChange={setSelectedModelId}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="选择3D模型" />
                  </SelectTrigger>
                  <SelectContent>
                    {MODEL_CONFIG.map((model) => (
                      <SelectItem key={model.id} value={model.id}>
                        {model.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              
              {/* 鼠标控制说明 */}
              <div className="mb-6">
                <MouseControlsInfo />
              </div>
              
              {/* 模型信息 */}
              {currentModel && (
                <div className="p-4 bg-muted/50 rounded-lg mb-6">
                  <h4 className="font-medium text-sm mb-2">模型信息</h4>
                  <p className="text-sm text-muted-foreground mb-2">
                    {currentModel.description}
                  </p>
                  {currentModel.path && (
                    <div className="text-xs text-muted-foreground">
                      <p>路径: {currentModel.path}</p>
                      <StatusIndicator currentModel={currentModel} />
                    </div>
                  )}
                </div>
              )}

              {/* 选中状态提示 */}
              {selectedImageUrl && (
                <div className="p-4 bg-amber-50 rounded-lg mb-6">
                  <h4 className="font-medium text-sm mb-2 flex items-center gap-2">
                    <ImageIcon className="h-4 w-4 text-amber-600" />
                    已选择图片
                  </h4>
                  <div className="flex items-center gap-2 mb-2">
                    <img 
                      src={selectedImageUrl} 
                      alt="已选择图片"
                      className="w-8 h-8 object-cover rounded"
                    />
                    <span className="text-sm flex-1">已选择图片，双击模型表面放置</span>
                  </div>
                  <div className="text-xs text-amber-700">
                    <p>• 在3D模型表面双击即可放置贴图</p>
                    <p>• 贴图将自动贴合模型曲面</p>
                  </div>
                </div>
              )}

              {/* 选中贴图提示 */}
              {selectedTextureId && (
                <div className="p-4 bg-blue-50 rounded-lg mb-6">
                  <h4 className="font-medium text-sm mb-2 flex items-center gap-2">
                    <ImageIcon className="h-4 w-4 text-blue-600" />
                    已选中贴图
                  </h4>
                  <div className="text-xs text-blue-700">
                    <p>• 双击模型表面移动贴图到新位置</p>
                    <p>• 贴图将自动重新计算曲面贴合</p>
                  </div>
                </div>
              )}

              {/* 贴图控制面板 */}
              {appliedTextures.length > 0 && (
                <div className="p-4 bg-green-50 rounded-lg mb-6">
                  <h4 className="font-medium text-sm mb-2 flex items-center gap-2">
                    <ImageIcon className="h-4 w-4 text-green-600" />
                    贴图控制
                  </h4>
                  
                  {/* 贴图大小调节 */}
                  <div className="mb-3">
                    <label className="text-xs font-medium mb-1 block">贴图大小</label>
                    <input
                      type="range"
                      min="0.1"
                      max="0.5"
                      step="0.05"
                      value={textureSize}
                      onChange={(e) => setTextureSize(parseFloat(e.target.value))}
                      className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                    <div className="flex justify-between text-xs text-muted-foreground">
                      <span>小</span>
                      <span>{textureSize.toFixed(2)}</span>
                      <span>大</span>
                    </div>
                  </div>
                  
                  <div className="space-y-2 max-h-32 overflow-y-auto">
                    {appliedTextures.map((texture, index) => (
                      <div 
                        key={texture.id} 
                        className={`flex items-center gap-2 text-xs p-2 rounded cursor-pointer ${
                          selectedTextureId === texture.id ? 'bg-blue-100 border border-blue-300' : 'bg-gray-50 hover:bg-gray-100'
                        }`}
                        onClick={() => handleTextureSelect(texture.id)}
                      >
                        <img 
                          src={texture.url} 
                          alt={`贴图 ${index + 1}`}
                          className="w-8 h-8 object-cover rounded"
                        />
                        <span className="flex-1 truncate">
                          贴图 {index + 1}
                          {selectedTextureId === texture.id && " (选中)"}
                        </span>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleRemoveTexture(texture.id);
                          }}
                        >
                          ×
                        </Button>
                      </div>
                    ))}
                  </div>
                  
                  {/* 应用大小调整按钮 */}
                  {selectedTextureId && (
                    <Button
                      onClick={() => {
                        toast({
                          title: "贴图大小已更新",
                          description: "贴图将重新计算曲面贴合",
                        });
                      }}
                      variant="outline"
                      size="sm"
                      className="w-full mt-2"
                    >
                      <RefreshCw className="h-3 w-3 mr-1" />
                      重新计算曲面贴合
                    </Button>
                  )}
                </div>
              )}

              {/* 贴图信息 */}
              <div className="p-4 bg-blue-50 rounded-lg mb-6">
                <h4 className="font-medium text-sm mb-2 flex items-center gap-2">
                  <ImageIcon className="h-4 w-4 text-blue-600" />
                  增强厚度智能曲面贴图功能
                </h4>
                <div className="text-xs text-blue-700 space-y-1">
                  <p>• ✅ <strong>增强厚度：</strong>贴图厚度增加3倍，视觉效果更立体</p>
                  <p>• ✅ <strong>增加表面距离：</strong>贴图与模型表面距离增加，避免穿透</p>
                  <p>• ✅ <strong>智能曲面检测：</strong>使用插值法线精确计算曲面方向</p>
                  <p>• ✅ <strong>动态贴合：</strong>移动贴图时自动重新计算曲面贴合</p>
                  <p>• ✅ <strong>防穿透技术：</strong>自动调整位置避免 z-fighting</p>
                  <p>• ✅ <strong>曲率适应：</strong>贴图自动适应模型表面曲率变化</p>
                </div>
              </div>

              {/* 操作说明 */}
              <div className="p-4 bg-primary/10 rounded-lg">
                <h4 className="font-medium text-sm mb-2 flex items-center gap-2">
                  <HelpCircle className="h-4 w-4" />
                  增强厚度智能曲面贴图说明
                </h4>
                <ul className="text-xs text-muted-foreground space-y-1">
                  <li>• ✅ <strong>增强厚度：</strong>贴图厚度从 0.05 增加到 0.15</li>
                  <li>• ✅ <strong>增加表面距离：</strong>从 0.01 增加到 0.03-0.05</li>
                  <li>• ✅ <strong>深度偏移优化：</strong>增加深度偏移因子防止穿透</li>
                  <li>• 鼠标左键拖拽旋转视图</li>
                  <li>• 鼠标滚轮缩放</li>
                  <li>• 选择图片后双击模型表面放置新贴图</li>
                  <li>• 点击已放置的贴图选中它</li>
                  <li>• 选中贴图后双击模型表面移动贴图到新位置</li>
                  <li>• 使用"清除贴图"按钮移除所有贴图</li>
                </ul>
              </div>
            </CardContent>
          </Card>
          
          {/* 3D预览区域 */}
          <Card className="lg:col-span-3 border-2 border-primary/20 overflow-hidden">
            <CardContent className="p-0">
              <div className="h-[70vh] w-full relative">
                {/* 只在选中历史图片且没有选中贴图时显示放置提示 */}
                {selectedImageUrl && !selectedTextureId && (
                  <div className="absolute inset-0 bg-amber-100/20 border-2 border-dashed border-amber-400 flex items-center justify-center z-10 pointer-events-none">
                    <div className="text-center bg-background/80 p-4 rounded-lg">
                      <ImageIcon className="h-8 w-8 text-amber-600 mx-auto mb-2" />
                      <p className="font-medium">双击模型表面放置图片</p>
                      <p className="text-sm text-muted-foreground">贴图将自动贴合曲面</p>
                    </div>
                  </div>
                )}
                
                {/* 只在选中贴图时显示移动提示 */}
                {selectedTextureId && (
                  <div className="absolute inset-0 bg-blue-100/20 border-2 border-dashed border-blue-400 flex items-center justify-center z-10 pointer-events-none">
                    <div className="text-center bg-background/80 p-4 rounded-lg">
                      <ImageIcon className="h-8 w-8 text-blue-600 mx-auto mb-2" />
                      <p className="font-medium">双击模型表面移动贴图</p>
                      <p className="text-sm text-muted-foreground">贴图将自动重新计算曲面贴合</p>
                    </div>
                  </div>
                )}
                
                {currentModel ? (
                  <ModelScene 
                    model={currentModel} 
                    appliedTextures={appliedTextures}
                    selectedTextureId={selectedTextureId}
                    onTextureSelect={handleTextureSelect}
                    onDoubleClick={handleModelDoubleClick}
                  />
                ) : (
                  <div className="h-full flex items-center justify-center text-destructive">
                    未找到模型配置
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
        
        {/* 历史图片区域 */}
        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-10">
          {/* 历史图片按钮 */}
          <Button
            onClick={toggleHistoryPanel}
            className={`gap-2 transition-all duration-300 ${
              isHistoryOpen ? "bg-primary text-primary-foreground" : "bg-secondary"
            }`}
            variant={isHistoryOpen ? "default" : "outline"}
          >
            <ImageIcon className={`h-4 w-4 transition-transform duration-300 ${
              isHistoryOpen ? "rotate-90" : ""
            }`} />
            历史图片
            <ChevronDown className={`h-4 w-4 transition-transform duration-300 ${
              isHistoryOpen ? "rotate-180" : ""
            }`} />
          </Button>
          
          {/* 历史图片面板 */}
          <div
            className={`mt-2 bg-card border rounded-lg shadow-lg transition-all duration-300 overflow-hidden ${
              isHistoryOpen 
                ? "max-h-40 opacity-100 translate-y-0" 
                : "max-h-0 opacity-0 -translate-y-2"
            }`}
            style={{ width: "80vw", maxWidth: "600px" }}
          >
            <div className="p-4">
              {isLoadingHistory ? (
                <div className="flex justify-center items-center py-2">
                  <RefreshCw className="h-4 w-4 animate-spin text-primary mr-2" />
                  <p className="text-sm text-muted-foreground">加载历史图片中...</p>
                </div>
              ) : historyImages.length > 0 ? (
                <>
                  {/* 横向滚动的图片列表 */}
                  <div 
                    className="flex gap-3 overflow-x-auto pb-3 scrollbar-thin scrollbar-thumb-rounded scrollbar-thumb-gray-300 scrollbar-track-transparent"
                    style={{ 
                      scrollbarWidth: 'thin',
                      scrollbarColor: '#d1d5db transparent'
                    }}
                  >
                    {historyImages.map((image) => (
                      <HistoryImageCard 
                        key={image.id} 
                        image={image} 
                        onSelect={handleImageSelect}
                        imageData={loadedImages[image.id]}
                      />
                    ))}
                  </div>
                  
                  {/* 选中的图片提示 */}
                  {selectedImageUrl && (
                    <div className="mt-3 pt-3 border-t border-border">
                      <div className="flex items-center gap-2">
                        <div className="w-6 h-6 rounded-full bg-primary/20 flex items-center justify-center">
                          <CheckCircle className="h-3 w-3 text-primary" />
                        </div>
                        <span className="text-sm font-medium">已选择图片</span>
                      </div>
                      <div className="mt-1 flex items-center gap-2">
                        <img 
                          src={selectedImageUrl} 
                          alt="Selected" 
                          className="w-8 h-8 object-cover rounded"
                        />
                        <p className="text-xs text-muted-foreground truncate flex-1">
                          双击模型表面放置（自动贴合曲面）
                        </p>
                        <Button 
                          variant="ghost" 
                          size="sm" 
                          className="h-6 text-xs"
                          onClick={handleDeselectImage}
                        >
                          取消
                        </Button>
                      </div>
                    </div>
                  )}
                </>
              ) : (
                <div className="text-center py-4 text-muted-foreground text-sm">
                  暂无历史图片
                </div>
              )}
            </div>
          </div>
        </div>
        
        {/* 使用指南 */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
          <h4 className="font-medium text-blue-800 mb-2 flex items-center gap-2">
            <AlertCircle className="h-4 w-4" />
            🎯 增强厚度智能曲面贴合技术
          </h4>
          <div className="text-sm text-blue-700 space-y-2">
            <p><strong>核心改进：</strong></p>
            <div className="ml-4">
              <p>• ✅ <strong>厚度增强：</strong>贴图厚度从 0.05 增加到 0.15（增加3倍）</p>
              <p>• ✅ <strong>表面距离：</strong>贴图与模型表面距离从 0.01 增加到 0.03-0.05</p>
              <p>• ✅ <strong>深度偏移优化：</strong>增加深度偏移因子防止穿透</p>
              <p>• ✅ <strong>几何体改进：</strong>使用立方体几何体替代平面，增加立体感</p>
              <p>• ✅ <strong>防穿透技术：</strong>自动调整位置避免 z-fighting</p>
            </div>
            <p><strong>操作指南：</strong></p>
            <div className="ml-4">
              <p>1. <strong>选择图片：</strong>从历史图片中选择</p>
              <p>2. <strong>精确放置：</strong>双击模型表面，贴图自动贴合曲面</p>
              <p>3. <strong>智能移动：</strong>选中贴图后双击新位置，自动重新计算曲面贴合</p>
              <p>4. <strong>厚度优化：</strong>贴图现在有更明显的厚度和立体感</p>
              <p>5. <strong>深度控制：</strong>自动计算最佳深度避免穿透</p>
            </div>
            <p className="font-medium mt-2">🎉 现在贴图具有更好的厚度和立体感，视觉效果更佳！</p>
          </div>
        </div>
      </div>
    </div>
  );
}